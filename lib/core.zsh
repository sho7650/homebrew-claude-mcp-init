#!/usr/bin/env zsh

# Core Library for Claude MCP Init - Simplified for v0.10.0
# Handles project structure and orchestration

# Load dependencies (avoiding double-loading)
if [[ -z "${UTILS_LOADED:-}" ]]; then
    source "${0:A:h}/utils.zsh"
fi
if [[ -z "${FILE_MANAGER_LOADED:-}" ]]; then
    source "${0:A:h}/file-manager.zsh"
fi
source "${0:A:h}/mcp-modules/base.zsh"

# Global configuration
typeset -r MCP_STARTER_VERSION="__VERSION__"  # Will be replaced during build

# Mark utils as loaded
typeset -r UTILS_LOADED=1

# Project structure creation with enhanced Zsh features
create_project_structure() {
    local project_name="$1"
    local in_place_mode="${2:-false}"
    local project_path
    
    if [[ "$in_place_mode" == "true" ]]; then
        # In-place mode: use current directory
        project_path="${PWD:A}"  # Zsh absolute path
        
        # Safety checks for in-place mode
        local existing_dirs=()
        [[ -d "${project_path}/.serena" ]] && existing_dirs+=(".serena/")
        [[ -d "${project_path}/memAgent" ]] && existing_dirs+=("memAgent/")
        
        if (( ${#existing_dirs} > 0 )); then
            print_warning "Warning: MCP configuration directories already exist in current directory" >&2
            for dir in $existing_dirs; do
                print_warning "  - $dir directory found" >&2
            done
            
            # Enhanced user input
            local reply
            print -n "Do you want to continue and potentially overwrite existing configuration? (y/n): " >&2
            read -q reply
            print >&2
            [[ "$reply" != "y" ]] && { print_error "Aborted." >&2; return 1 }
        fi
        
        # Check if we're in a git repository
        [[ -d "${project_path}/.git" ]] && {
            print_info "Note: You're initializing MCP configuration in a git repository" >&2
            print_info "The configuration files will be created in the repository root" >&2
        }
        
    else
        # Normal mode: create new project directory
        project_path="${PWD}/${project_name}"
        
        if [[ -d "$project_path" ]]; then
            print_warning "Warning: Project directory already exists: $project_path" >&2
            local reply
            print -n "Do you want to continue? (y/n): " >&2
            read -q reply
            print >&2
            [[ "$reply" != "y" ]] && { print_error "Aborted." >&2; return 1 }
        fi
        
        # Create project directory
        ensure_directory "$project_path"
    fi
    
    print "$project_path"
    return 0
}

# Configure MCP servers
configure_mcp_servers() {
    local project_path="$1"
    local -a mcp_modules=("${(@s:,:)2}")  # Split comma-separated modules
    shift 2
    local -A config=("$@")
    
    local mcp_file="${project_path}/.mcp.json"
    local env_file="${project_path}/.env"
    local -A all_env_vars=()
    
    # Initialize .mcp.json structure
    echo '{"mcpServers": {}}' > "$mcp_file"
    
    # Process each MCP module
    for module_name in $mcp_modules; do
        print_info "Configuring $module_name..."
        
        # Load the module directly
        local module_file="${LIB_DIR}/mcp-modules/${module_name}.zsh"
        if [[ ! -f "$module_file" ]]; then
            print_error "MCP module not found: $module_name"
            print_error "Searched: $module_file"
            continue
        fi
        
        # Source the module file
        source "$module_file" || {
            print_error "Failed to source module: $module_name"
            continue
        }
        
        # Validate requirements
        if ! mcp_validate_requirements; then
            print_error "Requirements not met for $module_name"
            continue
        fi
        
        # Generate module configuration
        mcp_generate_config "$project_path" "${(kv)config[@]}"
        
        # Get server configuration and add to .mcp.json
        local server_config=$(mcp_get_server_config "$project_path" "${(kv)config[@]}")
        update_mcp_json "$mcp_file" "$module_name" "$server_config"
        
        # Collect environment variables
        local env_vars=$(mcp_get_env_vars)
        if [[ -n "$env_vars" ]]; then
            while IFS='=' read -r key value; do
                all_env_vars[$key]="$value"
            done <<< "$env_vars"
        fi
    done
    
    # Create or update .env file with all collected env vars
    if (( ${#all_env_vars} > 0 )); then
        create_or_update_env "$env_file" "${(kv)all_env_vars[@]}"
    fi
    
    print_success "âœ“ MCP servers configured successfully"
}

# Create setup instructions
create_setup_instructions() {
    local project_path="$1"
    local -a mcp_modules=("${(@s:,:)2}")
    local instructions_file="${project_path}/MCP_SETUP_INSTRUCTIONS.md"
    
    cat > "$instructions_file" <<EOF
# MCP Server Setup Instructions

Generated by claude-mcp-init v${MCP_STARTER_VERSION}
Configured modules: ${(j:, :)mcp_modules}

## Prerequisites Checklist

1. **Environment Variables**
   - [ ] Review and update API keys in \`.env\` file
   - [ ] Verify all required API keys are set

2. **Install Dependencies**
EOF
    
    # Add module-specific instructions
    for module_name in $mcp_modules; do
        case "$module_name" in
            cipher)
                cat >> "$instructions_file" <<EOF
   
   **Cipher requirements:**
   - [ ] UV package manager: \`curl -LsSf https://astral.sh/uv/install.sh | sh\`
   - [ ] Cipher MCP server: \`uv add cipher-mcp\`
EOF
                ;;
            serena)
                cat >> "$instructions_file" <<EOF
   
   **Serena requirements:**
   - [ ] Node.js and npm (for Serena)
   - [ ] Serena will auto-install via uvx on first use
EOF
                ;;
        esac
    done
    
    cat >> "$instructions_file" <<EOF

## Quick Start

### 1. Set up Environment
\`\`\`zsh
# Source environment variables
source .env

# Verify API keys are set
env | grep -E 'API_KEY|KEY='
\`\`\`

### 2. Configure Your MCP Client
Use the generated \`.mcp.json\` file with your MCP client:

**For Claude Code:**
- Copy or merge \`.mcp.json\` settings into your Claude Code MCP configuration

**For Cursor:**
- Copy \`.mcp.json\` to \`.cursor/mcp.json\` (global) or project root (project-specific)

**For other MCP clients:**
- Use the server configurations from \`.mcp.json\`

## Configuration Files

- **\`.mcp.json\`** - Universal MCP server configuration
- **\`.env\`** - Environment variables (API keys)
EOF
    
    # Add module-specific config files
    for module_name in $mcp_modules; do
        case "$module_name" in
            serena)
                echo "- **\`.serena/project.yml\`** - Serena configuration" >> "$instructions_file"
                ;;
            cipher)
                echo "- **\`memAgent/cipher.yml\`** - Cipher configuration" >> "$instructions_file"
                ;;
        esac
    done
    
    cat >> "$instructions_file" <<EOF

## Troubleshooting

### API Keys
- Ensure all required API keys are set in \`.env\`
- Verify keys have sufficient credits and permissions

### Dependencies
- Check that all required tools are installed (uv, npm, etc.)
- Run the prerequisite installation commands if needed

## Additional Resources

- [Claude MCP Init Documentation](https://github.com/yourusername/claude-mcp-init)
- [MCP Protocol Documentation](https://modelcontextprotocol.io)
EOF
    
    print_success "Created setup instructions: $instructions_file"
}

# Enhanced help with modular options
show_help() {
    cat <<EOF
$(print -P "%F{blue}%Bclaude-mcp-init%b - Modular MCP server configuration tool v${MCP_STARTER_VERSION}%f")

$(print -P "%F{blue}%BUSAGE:%b%f")
    claude-mcp-init [OPTIONS] <PROJECT_NAME>

$(print -P "%F{blue}%BARGUMENTS:%b%f")
    <PROJECT_NAME>    Name of the project (used in configuration files)

$(print -P "%F{blue}%BCORE OPTIONS:%b%f")
    --mcp MODULES         Comma-separated list of MCP modules to configure (default: serena,cipher)
    -n, --in-place        Initialize in current directory instead of creating new project folder
    -h, --help            Show this help message
    -v, --version         Show version information
    --shell               Show detected shell information

$(print -P "%F{blue}%BMODULE OPTIONS:%b%f")
EOF
    
    # Show options for available modules
    local module_dir="${LIB_DIR}/mcp-modules"
    if [[ -d "$module_dir" ]]; then
        for module_file in "$module_dir"/*.zsh(N); do
            local module_name="${module_file:t:r}"
            if [[ "$module_name" != "base" ]]; then
                # Try to load module and get options
                if source "$module_file" 2>/dev/null && type "${module_name}_get_cli_options" &>/dev/null; then
                    local options=$(${module_name}_get_cli_options)
                    if [[ -n "$options" ]]; then
                        echo "$options"
                    fi
                fi
            fi
        done
    fi
    
    cat <<EOF

$(print -P "%F{blue}%BEXAMPLES:%b%f")
    # Configure both Serena and Cipher (default)
    claude-mcp-init my-project
    
    # Configure only Serena
    claude-mcp-init --mcp serena my-project
    
    # Configure with API keys
    claude-mcp-init --mcp cipher --cipher-openai-key sk-xxx my-project
    
    # Initialize in current directory
    claude-mcp-init -n --mcp serena,cipher my-project

$(print -P "%F{blue}%BAVAILABLE MODULES:%b%f")
EOF
    
    # List available modules
    local module_dir="${LIB_DIR}/mcp-modules"
    if [[ -d "$module_dir" ]]; then
        for module_file in "$module_dir"/*.zsh(N); do
            local module_name="${module_file:t:r}"
            if [[ "$module_name" != "base" ]]; then
                echo "    - $module_name"
            fi
        done
    else
        echo "    - serena"
        echo "    - cipher"
    fi
    
    cat <<EOF

For more information, visit: https://github.com/yourusername/claude-mcp-init
EOF
}

# Export core functions (quietly)
typeset -fx create_project_structure configure_mcp_servers create_setup_instructions show_help >/dev/null 2>&1