#!/usr/bin/env zsh

# Cipher MCP Module for Claude MCP Init
# Handles Cipher persistent memory layer configuration

# Module configuration
typeset -gA CIPHER_CONFIG=(
    [openai_key]=""
    [anthropic_key]=""
    [embedding_provider]=""
    [embedding_key]=""
    [system_prompt]="You are a coding assistant with persistent memory capabilities. You can remember context across conversations and provide contextually aware assistance."
)

# Validate Cipher requirements
cipher_validate_requirements() {
    # Check for Python and UV
    if ! command -v python3 &>/dev/null; then
        print_error "Cipher requires Python 3.11+"
        return 1
    fi
    
    if ! command -v uv &>/dev/null; then
        print_warning "UV package manager not found - will need to install: curl -LsSf https://astral.sh/uv/install.sh | sh"
    fi
    
    return 0
}

# Generate Cipher configuration
cipher_generate_config() {
    local project_path="$1"
    shift
    local -A config=("$@")
    local config_file="${project_path}/memAgent/cipher.yml"
    
    # Ensure directory exists
    ensure_directory "${project_path}/memAgent"
    
    # Determine primary provider based on available API keys
    local primary_provider="openai"
    local primary_model="gpt-4-turbo"
    
    if [[ -n "${config[anthropic_key]:-}" ]]; then
        primary_provider="anthropic"
        primary_model="claude-3-5-sonnet-20241022"
    fi
    
    # Generate simplified Cipher configuration (API keys via env vars)
    cat > "$config_file" <<EOF
# Cipher Configuration
# Generated by claude-mcp-init v${MCP_STARTER_VERSION:-0.10.0}

# LLM Configuration
llm:
  provider: ${primary_provider}
  model: ${primary_model}
  # API key is provided via environment variable

# System prompt for coding assistant
systemPrompt: '${CIPHER_CONFIG[system_prompt]}'

# Embedding Configuration (if specified)
$(if [[ -n "${CIPHER_CONFIG[embedding_provider]}" ]]; then
    case "${CIPHER_CONFIG[embedding_provider]}" in
        openai)
            echo "embedding:"
            echo "  type: openai"
            echo "  model: text-embedding-3-small"
            echo "  # API key provided via OPENAI_API_KEY env var"
            ;;
        gemini)
            echo "embedding:"
            echo "  type: gemini"
            echo "  model: text-embedding-004"
            echo "  # API key provided via GEMINI_API_KEY env var"
            ;;
        ollama)
            echo "embedding:"
            echo "  type: ollama"
            echo "  model: nomic-embed-text"
            echo "  baseUrl: http://localhost:11434"
            ;;
        *)
            echo "# Default embedding provider will be used"
            ;;
    esac
fi)
EOF
    
    print_success "Created Cipher configuration: $config_file"
    print_info "âœ“ Configured for ${primary_provider} provider with env-based API keys"
    
    return 0
}

# Get Cipher server configuration for .mcp.json
cipher_get_server_config() {
    local project_path="$1"
    shift
    local -A config=("$@")
    
    # Build environment variables object
    local env_vars=""
    local needs_comma=false
    
    if [[ -n "${config[openai_key]:-}" ]]; then
        env_vars="${env_vars}        \"OPENAI_API_KEY\": \"${config[openai_key]:-}\""
        needs_comma=true
    fi
    
    if [[ -n "${config[anthropic_key]:-}" ]]; then
        [[ "$needs_comma" == "true" ]] && env_vars="${env_vars},"
        env_vars="${env_vars}
        \"ANTHROPIC_API_KEY\": \"${config[anthropic_key]:-}\""
        needs_comma=true
    fi
    
    # Add embedding API keys if needed
    if [[ "${CIPHER_CONFIG[embedding_provider]}" == "gemini" && -n "${CIPHER_CONFIG[embedding_key]}" ]]; then
        [[ "$needs_comma" == "true" ]] && env_vars="${env_vars},"
        env_vars="${env_vars}
        \"GEMINI_API_KEY\": \"${CIPHER_CONFIG[embedding_key]}\""
    fi
    
    cat <<EOF
{
    "type": "stdio",
    "command": "cipher",
    "args": ["--mode", "mcp"],
    "env": {
${env_vars}
    }
}
EOF
}

# Get Cipher environment variables
cipher_get_env_vars() {
    local -A env_vars=()
    
    # Add API keys to environment
    [[ -n "${CIPHER_CONFIG[openai_key]}" ]] && env_vars[OPENAI_API_KEY]="${CIPHER_CONFIG[openai_key]}"
    [[ -n "${CIPHER_CONFIG[anthropic_key]}" ]] && env_vars[ANTHROPIC_API_KEY]="${CIPHER_CONFIG[anthropic_key]}"
    
    # Add embedding provider keys
    case "${CIPHER_CONFIG[embedding_provider]}" in
        gemini)
            [[ -n "${CIPHER_CONFIG[embedding_key]}" ]] && env_vars[GEMINI_API_KEY]="${CIPHER_CONFIG[embedding_key]}"
            ;;
        voyage)
            [[ -n "${CIPHER_CONFIG[embedding_key]}" ]] && env_vars[VOYAGE_API_KEY]="${CIPHER_CONFIG[embedding_key]}"
            ;;
        qwen)
            [[ -n "${CIPHER_CONFIG[embedding_key]}" ]] && env_vars[QWEN_API_KEY]="${CIPHER_CONFIG[embedding_key]}"
            ;;
    esac
    
    # Output as key=value pairs
    for key value in ${(kv)env_vars}; do
        echo "${key}=${value}"
    done
}

# Get Cipher metadata
cipher_get_metadata() {
    cat <<EOF
{
    "name": "cipher",
    "version": "1.0.0",
    "description": "Persistent memory layer for context-aware AI assistance"
}
EOF
}

# Get CLI options for Cipher
cipher_get_cli_options() {
    cat <<EOF
    --cipher-openai-key KEY       OpenAI API key for Cipher
    --cipher-anthropic-key KEY    Anthropic API key for Cipher
    --cipher-embedding PROVIDER   Embedding provider (openai, gemini, ollama, etc.)
    --cipher-embedding-key KEY    API key for embedding provider
EOF
}

# Process CLI arguments for Cipher
cipher_process_args() {
    local arg="$1"
    local value="$2"
    
    case "$arg" in
        --cipher-openai-key|--openai-key)
            CIPHER_CONFIG[openai_key]="$value"
            return 0
            ;;
        --cipher-anthropic-key|--anthropic-key)
            CIPHER_CONFIG[anthropic_key]="$value"
            return 0
            ;;
        --cipher-embedding)
            CIPHER_CONFIG[embedding_provider]="$value"
            return 0
            ;;
        --cipher-embedding-key)
            CIPHER_CONFIG[embedding_key]="$value"
            return 0
            ;;
    esac
    
    return 1
}

# Initialize Cipher module
cipher_init() {
    print_info "Cipher module loaded"
    return 0
}

# Cleanup Cipher resources
cipher_cleanup() {
    # No cleanup needed
    return 0
}

# Override base functions with cipher_ prefix
mcp_validate_requirements() { cipher_validate_requirements "$@"; }
mcp_generate_config() { cipher_generate_config "$@"; }
mcp_get_server_config() { cipher_get_server_config "$@"; }
mcp_get_env_vars() { cipher_get_env_vars "$@"; }
mcp_get_metadata() { cipher_get_metadata "$@"; }
mcp_get_cli_options() { cipher_get_cli_options "$@"; }
mcp_process_args() { cipher_process_args "$@"; }
mcp_init() { cipher_init "$@"; }
mcp_cleanup() { cipher_cleanup "$@"; }

# Mark as loaded
typeset -r CIPHER_MODULE_LOADED=1