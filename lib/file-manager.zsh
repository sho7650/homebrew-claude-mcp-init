#!/usr/bin/env zsh

# File Manager Library for Claude MCP Init
# Handles file operations and partial updates

# Zsh optimizations
setopt EXTENDED_GLOB
setopt NULL_GLOB

# Load utils if not already loaded
[[ -z "${UTILS_LOADED:-}" ]] && source "${0:A:h}/utils.zsh"

# Check if jq is available for JSON operations
has_jq() {
    command -v jq &>/dev/null
}

# Merge JSON files using jq or fallback to simple append
merge_json() {
    local target_file="$1"
    local new_content="$2"
    local merged_content
    
    if has_jq && [[ -f "$target_file" ]]; then
        # Use jq to merge JSON objects
        merged_content=$(jq -s '.[0] * .[1]' "$target_file" <(echo "$new_content") 2>/dev/null)
        if [[ $? -eq 0 && -n "$merged_content" ]]; then
            echo "$merged_content" > "$target_file"
            return 0
        fi
    fi
    
    # Fallback: simple overwrite
    echo "$new_content" > "$target_file"
}

# Update .mcp.json with new server configuration
update_mcp_json() {
    local mcp_file="$1"
    local server_name="$2"
    local server_config="$3"
    
    if ! has_jq; then
        print_warning "jq not found, will overwrite entire .mcp.json"
        return 1
    fi
    
    if [[ ! -f "$mcp_file" ]]; then
        # Create new file with initial structure
        echo '{"mcpServers": {}}' > "$mcp_file"
    fi
    
    # Add or update server in mcpServers
    local updated_json=$(jq --arg name "$server_name" --argjson config "$server_config" \
        '.mcpServers[$name] = $config' "$mcp_file" 2>/dev/null)
    
    if [[ $? -eq 0 && -n "$updated_json" ]]; then
        echo "$updated_json" > "$mcp_file"
        return 0
    fi
    
    return 1
}

# Add lines to .gitignore if not already present
update_gitignore() {
    local gitignore_file="$1"
    shift
    local -a patterns=("$@")
    
    # Create .gitignore if it doesn't exist
    [[ ! -f "$gitignore_file" ]] && touch "$gitignore_file"
    
    # Read existing patterns
    local -a existing_patterns=()
    if [[ -f "$gitignore_file" ]]; then
        existing_patterns=(${(f)"$(<$gitignore_file)"})
    fi
    
    # Add new patterns if not already present
    local added=false
    for pattern in $patterns; do
        if (( ${existing_patterns[(I)$pattern]} == 0 )); then
            echo "$pattern" >> "$gitignore_file"
            added=true
        fi
    done
    
    if [[ "$added" == "true" ]]; then
        print_info "Updated .gitignore with new patterns"
    fi
}

# Update or add environment variables in .env file
update_env_file() {
    local env_file="$1"
    local var_name="$2"
    local var_value="$3"
    
    # Create .env if it doesn't exist
    [[ ! -f "$env_file" ]] && touch "$env_file"
    
    # Check if variable already exists
    if grep -q "^${var_name}=" "$env_file" 2>/dev/null; then
        # Update existing variable
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS sed syntax
            sed -i '' "s|^${var_name}=.*|${var_name}=${var_value}|" "$env_file"
        else
            # GNU sed syntax
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$env_file"
        fi
    else
        # Add new variable
        echo "${var_name}=${var_value}" >> "$env_file"
    fi
}

# Create or update .env file with multiple variables
create_or_update_env() {
    local env_file="$1"
    shift
    local -A env_vars=("$@")
    
    # Add header if creating new file
    if [[ ! -f "$env_file" ]]; then
        cat > "$env_file" <<EOF
# Environment Variables for MCP Servers
# Generated by claude-mcp-init v${MCP_STARTER_VERSION:-0.10.0}

EOF
    fi
    
    # Update each environment variable
    for var_name var_value in ${(kv)env_vars}; do
        update_env_file "$env_file" "$var_name" "$var_value"
    done
}

# Safe file backup before modification
backup_file() {
    local file="$1"
    local backup_suffix="${2:-.bak}"
    
    if [[ -f "$file" ]]; then
        cp "$file" "${file}${backup_suffix}"
        return $?
    fi
    return 0
}

# Restore file from backup
restore_file() {
    local file="$1"
    local backup_suffix="${2:-.bak}"
    
    if [[ -f "${file}${backup_suffix}" ]]; then
        mv "${file}${backup_suffix}" "$file"
        return $?
    fi
    return 1
}

# Create directory with parent directories
ensure_directory() {
    local dir="$1"
    
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        return $?
    fi
    return 0
}

# Mark as loaded (avoid read-only conflicts)
[[ -z "${FILE_MANAGER_LOADED:-}" ]] && typeset FILE_MANAGER_LOADED=1

# Export functions (quietly)
typeset -fx has_jq merge_json update_mcp_json update_gitignore >/dev/null 2>&1
typeset -fx update_env_file create_or_update_env backup_file restore_file >/dev/null 2>&1
typeset -fx ensure_directory >/dev/null 2>&1