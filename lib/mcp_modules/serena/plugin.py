"""
Serena MCP Plugin - Semantic code toolkit for Claude
"""

import logging
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional

import click
import yaml

from mcp_modules.base import MCPModule
from claude_mcp_init.utils import (
    check_command, 
    validate_project_name, 
    is_valid_language, 
    normalize_language,
    ensure_directory,
    write_yaml_file
)

logger = logging.getLogger(__name__)


class SerenaPlugin(MCPModule):
    """Serena semantic code toolkit plugin"""
    
    @property
    def metadata(self) -> Dict[str, str]:
        """Return plugin metadata"""
        return {
            "name": "serena",
            "version": "1.0.0",
            "description": "Serena semantic code toolkit for intelligent code understanding and manipulation",
            "author": "Oraios Labs"
        }
    
    def get_cli_options(self) -> List[click.Option]:
        """Return CLI options for Serena plugin"""
        return [
            click.option(
                '--serena-language',
                help='Programming language for Serena (typescript, python, rust, java, go, cpp, ruby, csharp, javascript)'
            ),
            click.option(
                '--serena-read-only',
                is_flag=True,
                help='Enable read-only mode (disables editing tools)'
            ),
            click.option(
                '--serena-excluded-tools',
                help='Comma-separated list of tools to exclude'
            ),
            click.option(
                '--serena-initial-prompt',
                help='Initial prompt or context for the project'
            ),
        ]
    
    def validate_requirements(self) -> Tuple[bool, Optional[str]]:
        """Validate Serena requirements"""
        # Check for Node.js and npm
        if not check_command('node'):
            return False, "Serena requires Node.js to be installed"
        
        if not check_command('npm'):
            return False, "Serena requires npm to be installed"
        
        # Check for uv/uvx (optional but recommended)
        if not check_command('uvx') and not check_command('uv'):
            logger.warning("UV/UVX not found - Serena will be installed via uvx on first use")
        
        return True, None
    
    def generate_config_files(self, project_path: Path, config: Dict[str, Any]) -> None:
        """Generate Serena configuration files"""
        # Get language configuration
        language = config.get('serena_language') or config.get('language', 'typescript')
        
        # Normalize and validate language
        if not is_valid_language(language):
            logger.warning(f"Invalid language '{language}', falling back to typescript")
            language = 'typescript'
        
        language = normalize_language(language)
        
        # Get other configuration options
        project_name = config.get('project_name', project_path.name)
        read_only = config.get('serena_read_only', False)
        excluded_tools = config.get('serena_excluded_tools', '')
        initial_prompt = config.get('serena_initial_prompt', '')
        
        # Validate C# projects
        if language == 'csharp':
            sln_files = list(project_path.glob('*.sln'))
            if not sln_files:
                logger.warning("C# projects typically require a .sln file in the project folder")
        
        # Ensure .serena directory exists
        serena_dir = project_path / '.serena'
        ensure_directory(serena_dir)
        
        # Generate Serena configuration (official schema compliant)
        serena_config = {
            'language': language,
            'ignore_all_files_in_gitignore': True,
            'ignored_paths': [],
            'read_only': read_only,
            'excluded_tools': [tool.strip() for tool in excluded_tools.split(',') if tool.strip()],
            'initial_prompt': initial_prompt,
            'project_name': project_name
        }
        
        # Write configuration file
        config_file = serena_dir / 'project.yml'
        
        # Add comment header
        with config_file.open('w') as f:
            f.write(f"# Serena configuration for {project_name}\n")
            f.write(f"# Generated by claude-mcp-init v0.11.1\n")
            f.write(f"# Language: {language}\n\n")
            
            # Write YAML content
            yaml.safe_dump(serena_config, f, default_flow_style=False, sort_keys=False)
        
        logger.info(f"Created Serena configuration: {config_file}")
        logger.info("âœ“ Using official Serena schema with gitignore integration")
    
    def get_mcp_json_section(self, project_path: Path, config: Dict[str, Any]) -> Dict[str, Any]:
        """Return MCP server configuration for Serena"""
        abs_project_path = project_path.absolute()
        
        return {
            "type": "stdio",
            "command": "uvx",
            "args": [
                "--from",
                "git+https://github.com/oraios/serena",
                "serena",
                "start-mcp-server",
                "--context",
                "ide-assistant",
                "--project",
                str(abs_project_path)
            ],
            "env": {}
        }
    
    def get_env_variables(self, config: Dict[str, Any]) -> Dict[str, str]:
        """Return environment variables for Serena (none required)"""
        return {}
    
    def get_setup_instructions(self) -> List[str]:
        """Return setup instructions for Serena"""
        return [
            "**Serena Setup:**",
            "- Serena will be automatically installed via uvx on first use",
            "- No additional configuration required",
            "- Ensure Node.js and npm are available in your PATH",
            "",
            "**Verify Installation:**",
            "```bash",
            "# Test uvx installation (optional)",
            "uvx --from git+https://github.com/oraios/serena serena --help",
            "```"
        ]
    
    def get_default_config(self) -> Dict[str, Any]:
        """Return default configuration for Serena"""
        return {
            'language': 'typescript',
            'read_only': False,
            'excluded_tools': [],
            'initial_prompt': '',
            'ignore_gitignore': True
        }
    
    def validate_config(self, config: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
        """Validate Serena configuration"""
        # Validate project name if provided
        project_name = config.get('project_name')
        if project_name and not validate_project_name(project_name):
            return False, f"Invalid project name: {project_name}"
        
        # Validate language
        language = config.get('serena_language') or config.get('language')
        if language and not is_valid_language(language):
            return False, f"Unsupported language: {language}"
        
        return True, None
    
    def pre_install_hook(self, project_path: Path, config: Dict[str, Any]) -> None:
        """Pre-installation hook for Serena"""
        logger.debug("Serena pre-install hook: Validating project structure")
        
        # For C# projects, check for solution files
        language = config.get('serena_language') or config.get('language', 'typescript')
        if language == 'csharp':
            sln_files = list(project_path.glob('*.sln'))
            if not sln_files:
                logger.info("Consider adding a .sln file for optimal C# project support")
    
    def post_install_hook(self, project_path: Path, config: Dict[str, Any]) -> None:
        """Post-installation hook for Serena"""
        logger.debug("Serena post-install hook: Configuration complete")
        
        # Log success message
        language = config.get('serena_language') or config.get('language', 'typescript')
        logger.info(f"Serena configured for {language} project")
        
        # Provide helpful tips
        if language in ['python', 'javascript', 'typescript']:
            logger.info("ðŸ’¡ Tip: Serena works best with well-structured codebases")
        elif language == 'rust':
            logger.info("ðŸ’¡ Tip: Ensure your Cargo.toml is in the project root")
        elif language == 'go':
            logger.info("ðŸ’¡ Tip: Ensure your go.mod is in the project root")